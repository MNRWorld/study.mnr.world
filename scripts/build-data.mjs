import fs from "fs/promises";
import path from "path";
import { glob } from "glob";
import chokidar from "chokidar";

// Helper to create a camelCase key from a file path
function toCamelCase(str) {
  return str.replace(/[-_.\/]([a-z])/g, (g) => g[1].toUpperCase());
}

const ROOT_DATA_DIR = path.resolve(process.cwd(), "src/lib/data");
const OUTPUT_FILE = path.join(ROOT_DATA_DIR, "_generated.ts");
const ALL_JSON_PATTERN = path.join(ROOT_DATA_DIR, "**/*.json");

// Specific paths for the special university logic
const UNIVERSITIES_DIR = path.join(ROOT_DATA_DIR, "universities");
const PUBLIC_UNI_LIST_PATH = path.join(
  UNIVERSITIES_DIR,
  "public-universities.json",
);
const PRIVATE_UNI_LIST_PATH = path.join(
  UNIVERSITIES_DIR,
  "private-universities.json",
);
const INFO_FILE_PATTERN = path.join(UNIVERSITIES_DIR, "**/info.json");

async function buildUniversityData() {
  // This function now returns the data instead of writing a file
  console.log("  - Building university data...");
  try {
    const [publicUniList, privateUniList, infoFilePaths] = await Promise.all([
      fs.readFile(PUBLIC_UNI_LIST_PATH, "utf-8").then(JSON.parse),
      fs.readFile(PRIVATE_UNI_LIST_PATH, "utf-8").then(JSON.parse),
      glob(INFO_FILE_PATTERN),
    ]);

    const allBaseUniversities = [...publicUniList, ...privateUniList];
    const infoDataPromises = infoFilePaths.map(async (filePath) => {
      const content = await fs.readFile(filePath, "utf-8");
      if (content.trim() === "" || content.trim() === "{}") return null;
      try {
        const jsonContent = JSON.parse(content);
        const uniId = path.basename(path.dirname(filePath));
        return { id: uniId, ...jsonContent };
      } catch (e) {
        console.error(`  - ❌ Error parsing JSON from ${filePath}:`, e);
        return null;
      }
    });

    const allInfoData = (await Promise.all(infoDataPromises)).filter(Boolean);
    const infoDataMap = new Map(allInfoData.map((d) => [d.id, d]));

    const combinedData = allBaseUniversities.map((uni) => {
      const extraInfo = infoDataMap.get(uni.id) || {};
      return { ...uni, ...extraInfo };
    });
    console.log(
      `  - ✅ Finished university data for ${combinedData.length} universities.`,
    );
    return combinedData;
  } catch (error) {
    console.error("  - ❌ Error building university data:", error);
    return []; // Return empty array on error
  }
}

async function buildAllData() {
  console.log("🚀 Starting full data build...");
  const allData = {};

  try {
    // Handle the special university logic first
    allData.universities = await buildUniversityData();

    // Now process all other JSON files
    console.log("  - Building all other data...");
    const allJsonFiles = await glob(ALL_JSON_PATTERN);

    // Filter out the files already processed by buildUniversityData
    const otherJsonFiles = allJsonFiles.filter(
      (file) => !file.startsWith(UNIVERSITIES_DIR),
    );

    const otherDataPromises = otherJsonFiles.map(async (filePath) => {
      try {
        const content = await fs.readFile(filePath, "utf-8");
        if (content.trim() === "") return null;

        const jsonContent = JSON.parse(content);
        // Create a key from the file path relative to the root data dir
        // e.g., 'courses/list.json' -> 'coursesList'
        const relativePath = path.relative(ROOT_DATA_DIR, filePath);
        const key = toCamelCase(relativePath.replace(".json", ""));

        return { key, data: jsonContent };
      } catch (e) {
        console.error(`  - ❌ Error parsing JSON from ${filePath}:`, e);
        return null;
      }
    });

    const otherDataResults = (await Promise.all(otherDataPromises)).filter(
      Boolean,
    );
    otherDataResults.forEach(({ key, data }) => {
      allData[key] = data;
    });
    console.log(
      `  - ✅ Finished processing ${otherDataResults.length} other data files.`,
    );

    const fileContent = `// This file is auto-generated by scripts/build-data.mjs
// Do not edit this file directly.

export const allData = ${JSON.stringify(allData, null, 2)};
`;

    await fs.writeFile(OUTPUT_FILE, fileContent, "utf-8");
    console.log(
      `✅ Successfully built consolidated data file at src/lib/data/_generated.ts`,
    );
  } catch (error) {
    console.error("❌ Error building all data:", error);
    // Create an empty generated file on error to prevent build failures
    const errorFileContent = `// Auto-generation failed. Check build logs.
export const allData = {};
`;
    await fs.writeFile(OUTPUT_FILE, errorFileContent, "utf-8").catch((e) => {
      console.error("❌ Failed to write error fallback file:", e);
    });
  }
}

// --- Main Execution ---

const shouldWatch = process.argv.includes("--watch");

if (shouldWatch) {
  console.log(
    "👀 Watching for changes in all data files (src/lib/data/**/*.json)...",
  );
  const watcher = chokidar.watch(ALL_JSON_PATTERN, {
    ignored: /(^|[\\/\\\\])\\../, // ignore dotfiles
    persistent: true,
  });

  watcher.on("change", (filePath) => {
    console.log(`\n🔄 File changed: ${path.relative(process.cwd(), filePath)}`);
    buildAllData();
  });

  // Initial build
  buildAllData();
} else {
  buildAllData();
}
